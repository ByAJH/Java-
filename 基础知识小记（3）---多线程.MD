# 多线程
* 并发：指两个或多个时间在同一个时间段内发生。`慢`
* 并行：指两个或多个时间在同一时刻发生（同时发生）。`快`
* 进程：一个内存中运行的应用程序。
* 线程：进程中的一个执行单元，负责当前进程中程序的执行，一个进程至少有一个线程。如杀毒软件中可同时执行是杀毒、清理垃圾、电脑加速等线程。
* 线程调度
>     分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间
>     抢占式调度：优先让优先级高的线程使用CPU，优先级相同则随即选一个。如java使用抢占式调度。
## 1 创建线程类
* 主线程：执行主（main）方法的线程
* 单线程程序：java程序中只有一个线程，从main方法自上而下执行。
>     JVM执行main方法，main方法会进入到栈内存，JVM会找操作系统开辟一条main方法通向CPU的执行路径，
>     CPU就可以通过这个路径来执行main方法，而这个路径有一个名字，叫main（主）线程。
### 1.1 创建多线程程序的第一种方式：
#### （1）创建Thread类的子类
>     java.lang.Thread类：是描述线程的类，我们想要实现多线程程序，就必须继承Thread类
>>     实现步骤：
>>      1、创建一个Thread类的子类
>>      2、在Thread类的子类中重写Thread类中的run方法，设置线程任务（说说开启线程要干嘛）
>>      3、创建Thread类的子类对象
>>      4、调用Thread类中的方法start方法，开启新的线程，执行run方法
#### （2）多线程中的几种操作
##### 获取线程的名称
>     1、使用Thread类中的方法getName（），String getName（）返回该线程的名称。
>     2、可以先获取到当前正在执行的线程，使用线程中的方法getName（）获取线程的名称。 static Thread currentThread（）返回对当前正在执行的线程对象的引用。
>>     Thread.currentThread().getName(),    
>>     类Thread调用静态方法currentThread（）得到线程对象，线程对象再调用getName。
##### 设置线程的名称
>     1、使用Thread类中的方法setName（名字）
>>     void setName（String name）改变线程名称，使之与参数name相同。
>     2、创建一个带参数的构造方法，参数传递线程的名称：调用父类的带参数构造方法，吧线程名称传递给父类，让父类（Thread）给子线程起一个名字
>>     子类带参数构造方法中写：super（name）；
#### 延时执行
>     public static void sleep(long millis)：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。之后继续执行。
>>    该方法本身会产生异常，try或throw处理。
### 1.2 创建多线程方式二（实现Runnable接口）
* 步骤： 
>     1. 定义类实现Runnable接口。 
>     2. 覆盖接口中的run方法。将线程任务代码定义到run方法中。 
>     3. 创建Thread类的对象。 
>     4. 将Runnable接口的子类对象作为参数传递给Thread类的构造函数。 
>     5. 调用Thread类的start方法开启线程。
* 好处
>     1.避免了继承Thread类的单继承的局限性。
>     2.Runable接口出现更符合面向对象，将线程单独进行对象的封装。
>     3.Runnable接口出现，降低了线程对象和线程任务的耦合性。** 所以创建线程的方式都使用Runnable接口。 **
>>    实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离
>>    实现类中，重写了run方法：用来设置线程任务
>>    创建Thread类中的start方法，开启新的线程：用来开启新线程
### 1.3 使用匿名内部类实现：简化代码
## 2 线程与安全问题
>     如多个线程同时执行一个任务，  ~~截图~~
### 2.1 安全问题的解决方法
* 同步代码块
>     synchronized（锁对象）{可能会出现线程安全问题的代码块（访问了共享数据的代码）}
>>      注意：
>>      1、通过代码块中的锁对象，可以使用任意的对象
>>      2、但是必须保证多个线程使用的锁对象是同一个
>>      3、锁对象的作用就是把同步代码块锁住，只让一个线程在同步代码块中执行。
~~+++插入图片说明同步技术原理+++~~
* 同步方法
>     把方法内部代码锁住，只让一个线程执行，
>     public synchronized void 方法名（）{共享代码}    ，，，其锁对象是this，即谁调用就是谁 
>     静态：public static synchronized void 方法名（）{共享代码} ，，，其锁对象不能是this，因为其优先于对象产生，而是本类的class属性--->class文件对象（反射）
* 锁机制（Lock锁）
>      使用步骤：
>      1、在成员位置创建一个ReentrantLock对象，其实现了Lock接口。
>      2、在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
>      3、在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁
>   可将unlock放在try...catch后的finally块中，无论是否产生异常，都释放锁，提高效率。
## 3 线程的状态
* NEW状态（新建状态）
* RUNNABLE状态（运行状态）
* BLOCKED（阻塞状态）
* TERMINATED（死亡状态）
* TIMED_WAITING（休眠状态）：可自己醒
* WAITING（无线等待状态）：Object.wait（）进入等待，用Object.notify（）唤醒。，只有锁对象才能调用这两 个方法
## 4 等待唤醒机制：线程之间的通信，可有效利用资源
* 调用wait和notify方法需要注意的细节
>     1、wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程
>     2、wait方法与notify方法是属于Object类的方法的。因为锁对象可以是任意对象，而任意对象的所属类都是继承了Object。
>     3、wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。
* 案例包子买卖
## 5 线程池
* 其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。
  * 线程池使用步骤：
>     1、使用线程池的工厂类Executors的静态方法newFixedThreadPool生产一个指定线程数量的线程池；
>>      ExecutorService es = Executors.newFixedThreadPool(线程数量);返回ExecutorService接口的实现类--->线程池 
>     2、创建一个类，实现Runnable接口，重写run方法，设置线程任务；
>     3、调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法；
>     4、调用ExecutorService中的方法shutdown销毁线程池（不建议使用）。
